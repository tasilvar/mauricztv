<?php

/*
 * CRON - pobranie ID użytkowników i wysłanie emaila przypominającego
 * o wygasającym terminie dostępu do treści
 *
 * @package     EDD Paid Content
 * @subpackage  Includes
 * @copyright   Copyright (c) 2015, upSell.pl & Better Profits
 */

if ( !defined( 'ABSPATH' ) )
	exit;

global $edd_options;

// Wysyłka raportów o wygasłych subskrypcjach
$reports = get_transient( 'bpmj_eddpc_renewals_report' );
if ( is_array( $reports ) && isset( $edd_options[ 'bpmj_expired_access_report_email' ] ) && !empty( $edd_options[ 'bpmj_expired_access_report_email' ] ) ) {
	foreach ( $reports as $date => $users ) {
		if ( time() > $date ) {

			$count = 0;

			$msg_users = '<ol>';
			foreach ( $users as $user_id => $products ) {
				$user = get_userdata( $user_id );

				$access_time = get_user_meta( $user_id, "_bpmj_eddpc_access", true );

				$msg_users .= '<li>' . $user->first_name . ' ' . $user->last_name . ' <b>(' . $user->user_email . ')</b><ul>';

				foreach ( $products as $product_id ) {
					// sprawdzenie, czy przypadkiem czas nie został przedłużony
					if ( isset( $access_time[ $product_id ][ 'access_time' ] ) && $access_time[ $product_id ][ 'access_time' ] < time() ) {
						$msg_users .= '<li><a href="' . get_permalink( $product_id ) . '">' . get_the_title( $product_id ) . '</a></li>';
						$count++;
						do_action( 'bpmj_eddpc_access_expired', $user_id, $product_id );
					}
				}
				$msg_users .= '</ul></li>';
			}

			$msg_users .= '</ol>';
			$message = nl2br( sprintf( __( 'Hello! <br> <br> Here is a list of users who have expired to access these products on <b>%s</b>:<br>%s<br><br>--<br>Report generated by EDD Paid Content', 'bpmj-eddpd' ), date( 'd-m-Y', $date ), $msg_users ) );

			if ( !empty( $count ) ) {
				EDD()->emails->send( $edd_options[ 'bpmj_expired_access_report_email' ], sprintf( __( 'Raport EDD Paid Content of %s', 'edd-paid-content' ), date( 'd-m-Y', $date ) ), $message );
			}
			delete_transient( 'bpmj_eddpc_renewals_report' );
		}
	}
}




// Sprawdzamy czy możemy ruszyć z cronem
$currentTime = current_time( 'H' );
$startTime	 = isset( $edd_options[ 'bpmj_renewals_start' ] ) ? $edd_options[ 'bpmj_renewals_start' ] : 6;
$endTime	 = isset( $edd_options[ 'bpmj_renewals_end' ] ) ? $edd_options[ 'bpmj_renewals_end' ] : 22;

if ( $currentTime >= $startTime && $currentTime <= $endTime ) {

	// Liczba użytkowników do pobrania przy jednym zapytaniu
	$one_query_users = 50;

	// Od którego użytkownika zacząć pobieranie
	$users_count		 = count_users();
	$users_count		 = $users_count[ 'total_users' ];
	$cron_users_offset	 = get_transient( 'bpmj_eddpc_cron_users_offset' );

	if ( isset( $cron_users_offset ) && $users_count > $cron_users_offset ) {
		$offset = $cron_users_offset;
	} else {
		$offset = 0;
		delete_transient( 'bpmj_eddpc_cron_users_offset' );
	}


	// WP Query
	$args				 = array(
		'fields' => 'ID',
		'number' => $one_query_users
	);
	if ( $offset )
		$args[ 'offset' ]	 = (int) $offset;

	$user_query	 = new WP_User_Query( $args );
	$users		 = $user_query->get_results();

	// Pobranie wyników
	if ( empty( $users ) )
		return;

	foreach ( $users as $user_id ) {

		// Czas dostępu do poszczególnych zakupionych produktów
		$access_time = get_user_meta( $user_id, "_bpmj_eddpc_access", true );

		if ( is_array( $access_time ) ) {
			foreach ( $access_time as $product_id => $access ) {

				/**
				 * Do testów: ustawianie customowej daty
				  $date = new DateTime('2016-04-13');
				  $beginOfDay = strtotime( "midnight", $date->getTimestamp() );
				 */
				$beginOfDay	 = strtotime( "midnight", time() );
				$endOfDay	 = strtotime( "tomorrow", $beginOfDay ) - 1;


				// Jeżeli czas dostępu kończy się dzisiaj - zapisz informacje do raportu
				if ( isset( $access[ 'access_time' ] ) && $access[ 'access_time' ] >= $beginOfDay && $access[ 'access_time' ] <= $endOfDay ) {

					// Zapisanie informacji do tablicy o wysłaniu powiadomienia (do ogólnych raportów)
					$reports = get_transient( 'bpmj_eddpc_renewals_report' );

					if ( !is_array( $reports[ $endOfDay ][ $user_id ] ) )
						$reports[ $endOfDay ][ $user_id ] = array();

					if ( !in_array( $product_id, $reports[ $endOfDay ][ $user_id ] ) ) {
						$reports[ $endOfDay ][ $user_id ][] = $product_id;
						set_transient( 'bpmj_eddpc_renewals_report', $reports );
					}
				}

				if ( function_exists( 'edd_user_has_recurring_payments' ) && edd_user_has_recurring_payments( $user_id, $product_id ) ) {
					bpmj_eddpc_maybe_send_payment_notice( $user_id, $product_id );

					/*
					 * If the user has any recurring payments for this product, we shouldn't send her any
					 * renewal emails
					 */
					continue;
				}

				// Jeżeli produkt nie został kupiony dzisiaj
				//if ( isset( $access[ 'buy_time' ] ) && $access[ 'buy_time' ] != strtotime( date( 'd.m.Y' ) ) ) {
				// Jeżeli czas dostępu jest większy niż obecna data
				if ( isset( $access[ 'access_time' ] ) && $access[ 'access_time' ] > time() ) {

					// Pobranie ustalonych przez admina przypomnień
					$renewals		 = bpmj_eddpc_get_renewals('renewal');
					$send_periods	 = false;

					if ( is_array( $renewals ) ) {
						foreach ( $renewals as $renewal_id => $renewal ) {

							$date		 = new DateTime();
							$date->setTimestamp( $access[ 'access_time' ] );
							$date->modify( $renewal[ 'send_period' ] );
							$send_date	 = $date->getTimestamp();

							$send	 = isset( $access[ 'renewals' ][ $renewal[ 'send_period' ] ] ) && $access[ 'renewals' ][ $renewal[ 'send_period' ] ] ? $access[ 'renewals' ][ $renewal[ 'send_period' ] ] : false;
							$send	 = apply_filters( 'bpmj_eddpc_cron_renewals_send', $send, $user_id, $product_id );

							// Czy powiadomienie nie zostało już wysłane
							if ( !$send ) {

								/**
								 * Jeżeli data wysyłki mieści się w przedziale dnia dzisiejszego
								 * należy wysłać odpowiednie powiadomienie i
								 * zapisać wysyłkę do meta użytkownika
								 */
								if ( $send_date >= $beginOfDay && $send_date <= $endOfDay ) {

									$access_time															 = get_user_meta( $user_id, "_bpmj_eddpc_access", true );
									// Oznaczenie aktualnego okresu wysyłki jako wysłane
									$access_time[ $product_id ][ 'renewals' ][ $renewal[ 'send_period' ] ]	 = true;

									// Aktualizacja meta danych użytkownika
									update_user_meta( $user_id, '_bpmj_eddpc_access', $access_time );

									// Wysyłka email
									bpmj_eddpc_renewal_email( $user_id, $product_id, $renewal_id, $access[ 'access_time' ] );
								}
							}
						}
					}
				}
				//}
			}
		}
	}

	set_transient( 'bpmj_eddpc_cron_users_offset', $offset + $one_query_users );
}